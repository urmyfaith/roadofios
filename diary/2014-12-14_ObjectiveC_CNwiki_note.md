
- 调用方法

> Objective-C里,与其说 对象互相调用方法,不如说对象之间互相传递消息更为精确

~

> 但是Objective-C里,我们应当解读为“发提交 一个fly的消息给car对象”,fly是消息,而car是消息的接收者。car收到消息后会决定如何回应这个消息,若car类内定义有fly方法就运行方法内之代 码,若car内不存在fly方法,则程序依旧可以通过编译,运行期则抛出异常。


~

- oc的方法命名

> Objective-C定义一个新的方法时,名称内的冒号(:)代表参数传递,不同于C语言以数学函数的括号来传递参数。Objective-C方法使得参数可以夹杂 于名称中间,不必全部附缀于方法名称的尾端,可以提高程序可读性
- 实例变量定义的位置> 值得一提的是不只Interface区段可定义实体变量,Implementation区段也可以定义实体变量,两者的差别在于访问权限的不同,Interface区段内的实 体变量默认权限为protected,声明于implementation区段的实体变量则默认为private,故在Implementation区段定义私有成员更符合面向对象之封 装原则,因为如此类之私有信息就不需曝露于公开interface(.h文件)中
- 协议
~ > 正式协议类似于Java中的"接口",它是一系列方法的列表,任何类都可以声明自身实现了某个协议。在Objective-C 2.0之前,一个类必须实现它声明符 合的协议中的所有方法,否则编译器会报告错误,表明这个类没有实现它声明符合的协议中的全部方法。Objective-C 2.0版本允许标记协议中某些方法 为可选的(Optional),这样编译器就不会强制实现这些可选的方法。

~

> 协议经常应用于Cocoa中的委托及事件触发。例如文本框类通常会包括一个委托(delegate)对象,该对象可以实现一个协议,该协议中可能包含一个 实现文字输入的自动完成方法。若这个委托对象实现了这个方法,那么文本框类就会在适当的时候触发自动完成事件,并调用这个方法用于自动完成功 能。- 动态绑定> 类似于Smalltalk,Objective-C具备动态类型:即消息可以发送给任何对象实体,无论该对象实体的公开接口中有没有对应的方法
> 虽然Objective-C具备动态类型的能力,但编译期的静态类型检查依旧可以应用到变量上。
- 转发
> 转发可以 用于简化特定的设计模式,例如观测器模式或代理模式。
-  类别
> 类别 (Category)在Objective-C的设计中,一个主要的考虑即为大型代码框架的维护。结构化编程的经验显示,改进代码的一种主要方法即为将其分解为更小的片段。 Objective-C借用并扩展了Smalltalk实现中的“分类”概念,用以帮助达到分解代码的目的
> **分类中的方法是在运行时被加入类中的**
> **若分类声明了与类中原有方法同名的函数,则分类中的方法会被调用。因此分类不仅可以增加类的方法,也可以代替原有的方法。这个特性可以用于修正原有代码中的错误,更可以从根本上改变程序中原有类的行为。若两个分类中的方法同名,则被调用的方法是不可预测的。**
-  扮演
> 扮演Objective-C允许一个类在程序中完全取代另一个类,这种行为称为前者“扮演”目标类。
- 快速枚举
> Objective-C 2.0提供了快速枚举的语法
- 垃圾回收
> Objective-C的最初版本并不支持垃圾回收(garbage collection)。在当时这是争论的焦点之一,很多人考虑到Smalltalk回收时有漫长的“死亡时 间”,令整个系统失去功用,Objective-C为避免此问题才不拥有这个功能。某些第三方版本加入了这个功能(尤是GNUstep),苹果公司也在其Mac OS X 10.5中提供了实现。
- 命名空间
> 另一个广受批评的问题是ObjC不包括名字空间机制(namespace mechanism)