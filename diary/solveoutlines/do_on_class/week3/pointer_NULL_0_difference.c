#include <stdio.h>
#include <stdlib.h>

void test(int *q)
{
	*q = 5;
}

int main(void)
{
#if 0
	int *p = (int *)malloc(sizeof(int));
	test(p);
#endif

#if 0
	int *p = NULL;
	test(p);
#endif

#if 0
	int *p = NULL;
	int a=3;
	p = &a;
#endif

#if 0
	int *p = 0;
	test(p);
#endif

	printf("%d",*p);

	return 0;
}

/*
 *很多初学者都无法分清这两者之间的区别。我们先看下面的代码：
 int *p = NULL;
 这时候我们可以通过编译器查看p 的值为0×00000000。这句代码的意思是：定义一个指针
 变量p，其指向的内存里面保存的是int 类型的数据；在定义变量p 的同时把p 的值设置为
 0×00000000，而不是把*p 的值设置为0×00000000。这个过程叫做初始化，是在编译的时候
 进行的。
 明白了什么是初始化之后，再看下面的代码：
 int *p;
 *p = NULL;
 同样，我们可以在编译器上调试这两行代码。第一行代码，定义了一个指针变量p，其指向
 的内存里面保存的是int 类型的数据；但是这时候变量p 本身的值是多少不得而知，也就是
 说现在变量p 保存的有可能是一个非法的地址。第二行代码，给*p 赋值为NULL，即给p
 指向的内存赋值为NULL；但是由于p 指向的内存可能是非法的，所以调试的时候编译器可
 能会报告一个内存访问错误。这样的话，我们可以把上面的代码改写改写，使p 指向一块合
 法的内存：
 int i = 10;
 int *p = &i;
 *p = NULL;
 在编译器上调试一下，我们发现p 指向的内存由原来的10 变为0 了；而p 本身的值， 即内
 存地址并没有改变。
 经过上面的分析，相信你已经明白它们之间的区别了。不过这里还有一个问题需要注
 意，也就是这个NULL。初学者往往在这里犯错误。
 注意NULL 就是NULL，它被宏定义为0：
#define NULL 0
很多系统下除了有NULL外，还有NUL（Visual C++ 6.0 上提示说不认识NUL）。NUL 是ASCII
码表的第一个字符，表示的是空字符，其ASCII 码值为0。其值虽然都为0，但表示的意思
完全不一样。同样，NULL 和0 表示的意思也完全不一样。一定不要混淆。
另外还有初学者在使用NULL 的时候误写成null 或Null 等。这些都是不正确的，C 语
言对大小写十分敏感啊。当然，也确实有系统也定义了null，其意思也与NULL 没有区别，
但是你千万不用使用null，这会影响你代码的移植性。

 *
 * */
