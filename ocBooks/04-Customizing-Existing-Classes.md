# Customizing Existing Classes自定义现有类

Objects should have clearly-defined tasks, such as modeling specific information, displaying visual content or controlling the flow of information. (一个对象应该有明确的任务,例如修改指定的信息,显示某些内容,信息.)As you’ve already seen, a class interface defines the ways in which others are expected to interact with an object to help it accomplish those tasks.(在前面已经介绍了,一个类接口定义了很多接口,这样的话,其他的类就可以这个类来交互,达到一起完成任务的目标.)
Sometimes, you may find that you wish to extend an existing class by adding behavior that is useful only in certain situations.(有时候,你可以能会希望对现有的类来增加功能.) As an example, you might find that your application often needs to display a string of characters in a visual interface.(例如,很多时候你的应用需要在用户界面上显示一个字符串.) Rather than creating some string-drawing object to use every time you need to display a string, it would make more sense if it was possible to give the NSString class itself the ability to draw its own characters on screen.(这个时候就不要去每次都创建一个字符串对象,如果我们给NSString类一个在屏幕上显示字符串的能力,岂不是更好?)
In situations like this, it doesn’t always make sense to add the utility behavior to the original, primary class interface.(在有些情况下,例如对基类接口,添加工具方法就不合适了.) Drawing abilities are unlikely to be needed the majority of times any string object is used in an application, for example, and in the case of NSString, you can’t modify the original interface or implementation because it’s a framework class.(对于NSString来说,因为这是一个系统类,你不能修改这个框架类,所有就没有办法通过修改这个文件来添加方法了.)
Furthermore, it might not make sense to subclass the existing class, because you may want your drawing behavior available not only to the original NSString class but also any subclasses of that class, like NSMutableString.(所有时候,我们需要的是对现有类的增加功能,这样子类都有父类的功能,例如NSMutableString,这样就不能使用继承.) And, although NSString is available on both OS X and iOS, the drawing code would need to be different for each platform, so you’d need to use a different subclass on each platform.(而且同样的方法,在不同的平台上的实现也不同,所以需要每个平台上这个类的子类.)
Instead, Objective-C allows you to add your own methods to existing classes through categories and class extensions.(这个时候,OC里可以通过对现有的类进行分类和扩展来达到我们的目的.)
## Categories Add Methods to Existing Classes 分类来对现在的类增加功能
If you need to add a method to an existing class, perhaps to add functionality to make it easier to do something in your own application, the easiest way is to use a category.(如果需要对现有的类增加功能的话,最方便的方法是使用分类)
The syntax to declare a category uses the @interface keyword, just like a standard Objective-C class description, but does not indicate any inheritance from a subclass. (声明分类的时候使用@interface关键字,但是不需要继承自父类.)Instead, it specifies the name of the category in parentheses, like this:(而是可以在括号中指定分类的名称:)```Objective-c
 @interface ClassName (CategoryName) @end
```A category can be declared for any class, even if you don’t have the original implementation source code (such as for standard Cocoa or Cocoa Touch classes). (可以对任何类进行分类,即使你对类原来的具体的代码实现不知道,例如系统的类.)Any methods that you declare in a category will be available to all instances of the original class, as well as any subclasses of the original class.(对类添加方法后,这个方法可以在现有类和子类都使用.) At runtime, there’s no difference between a method added by a category and one that is implemented by the original class.(在允许时刻,一个方法是通过分类添加的,还是原有的,都一样处理,没有任何区别.)
Consider the XYZPerson class from the previous chapters, which has properties for a person’s first and last name.(例如,有两个属性(姓,名)的一个XYZPersn类,) If you’re writing a record-keeping application, you may find that you frequently need to display a list of people by last name, like this:(在一个排行榜应用的开发过程中,你会发现经常需要显示姓名列表:)
```Objective-c
Appleseed, JohnDoe, JaneSmith, BobWarwick, Kate
```Rather than having to write code to generate a suitable lastName, firstName string each time you wanted to display it, you could add a category to the XYZPerson class, like this:
(与其每次需要的时候都去生成,还不如对现有的类添加一个分类:)

```Objective-c
#import "XYZPerson.h"@interface XYZPerson (XYZPersonNameDisplayAdditions)- (NSString *)lastNameFirstNameString;@end
```

In this example, the XYZPersonNameDisplayAdditions category declares one additional method to return the necessary string.(在这个例子中,XYZPersonNameDisplayAdditions分类添加了一个分类的方法来返回需要的字符串.)
A category is usually declared in a separate header file and implemented in a separate source code file. (分类通常是在不同的头头文件之中声明的,也在不同的源文件中实现.)In the case of XYZPerson, you might declare the category in a header file called XYZPerson+XYZPersonNameDisplayAdditions.h.(对XYZPerson这个例子,声明分类的头文件的名称可能是"XYZPerson+XYZPersonNameDisplayAdditions.h")
Even though any methods added by a category are available to all instances of the class and its subclasses, you’ll need to import the category header file in any source code file where you wish to use the additional methods, otherwise you’ll run into compiler warnings and errors.(尽管分类方法在所有的类实例和子类中都可以使用,但是,在你使用的时候,需要导入分类的头文件,不然的话就会有一个编译警告和错误.)
The category implementation might look like this:(一个分类的实现可以写成这样子.):
```Objective-c
#import "XYZPerson+XYZPersonNameDisplayAdditions.h"
 @implementation XYZPerson (XYZPersonNameDisplayAdditions)  - (NSString *)lastNameFirstNameString {      return [NSString stringWithFormat:@"%@, %@", self.lastName, self.firstName];  }@end
```

Once you’ve declared a category and implemented the methods, you can use those methods from any instance of the class, as if they were part of the original class interface:(一旦声明了分类,实现了类方法,在类的实例和子类的实例中就可以使用分类中的方法了,而且感觉这方法就像在原有的类中一样.)

```Objective-c
#import "XYZPerson+XYZPersonNameDisplayAdditions.h"@implementation SomeObject- (void)someMethod {    XYZPerson *person = [[XYZPerson alloc] initWithFirstName:@"John"                                                    lastName:@"Doe"];    XYZShoutingPerson *shoutingPerson =                        [[XYZShoutingPerson alloc] initWithFirstName:@"Monica"                                                           lastName:@"Robinson"];NSLog(@"The two people are %@ and %@",[person lastNameFirstNameString], [shoutingPerson lastNameFirstNameString]);} @end
```

As well as just adding methods to existing classes, you can also use categories to split the implementation of a complex class across multiple source code files.(正如通过分类可以对现有的类增加方法一样,你也可以使用分类来对一个复杂的类在几个不同的源文件中去实现.) You might, for example, put the drawing code for a custom user interface element in a separate file to the rest of the implementation if the geometrical calculations, colors, and gradients, etc, are particularly complicated. (例如,你可以对某个用户界面的绘制分到不同部分,例如几何计算,颜色,斜坡等等.)Alternatively, you could provide different implementations for the category methods, depending on whether you were writing an app for OS X or iOS.(或者,你可以提供针对不同的平台提供不同的实现方法.)
Categories can be used to declare either instance methods or class methods but are not usually suitable for declaring additional properties. (**分类可以用来声明实例方法/类方法,但是通常不适合声明额外的属性.**)It’s valid syntax to include a property declaration in a category interface, but it’s not possible to declare an additional instance variable in a category.(在一个分类的接口里声明属性是可以的,但是在分类中声明一个额外的实例变量是不可以的.) This means the compiler won’t synthesize any instance variable, nor will it synthesize any property accessor methods. (也就是说编译不会自动合成实例变量,也不会合成任何存取器方法.)You can write your own accessor methods in the category implementation, but you won’t be able to keep track of a value for that property unless it’s already stored by the original class.(**在分类的实现里可以自己编写存取器方法,除非在原有的类中有这个属性,否则的话,是不肯能保存,追踪这个属性值的.**)
The only way to add a traditional property—backed by a new instance variable—to an existing class is to use a class extension, as described in Class Extensions Extend the Internal Implementation (page 72).(对一个现有的类,添加一个传统的属性的唯一的方法就是使用**类扩展**,这将在"使用类扩展来扩充内部实现")
>Note: 
> Cocoa and CocoaTouch include a variety of categories for some of the primary framework classes.(系统框架中,对很多重要的框架类提供了大量的分类.)
> The string-drawing functionality mentioned in the introduction to this chapter is in fact already provided for NSString by the NSStringDrawing category for OS X, which includes the drawAtPoint:withAttributes: and drawInRect:withAttributes: methods. (在OS X中,string-draw方法已经作为NSString的分类中的一个方法提供使用.)For iOS, the UIStringDrawing category includes methods such as drawAtPoint:withFont: and drawInRect:withFont:.(在iOS中,UIStringDrawing分类包含了例如drawAtPoint:withFont: 和 drawInRect:withFont:等方法);
### Avoid Category Method Name Clashes 避免分类方法名冲突
Because the methods declared in a category are added to an existing class, you need to be very careful about method names.(给一个分类添加方法的时候,需要十分小心类名的处理.)If the name of a method declared in a category is the same as a method in the original class, or a method in another category on the same class (or even a superclass), the behavior is undefined as to which method implementation is used at runtime.(**如果分类中的方法名和原有的类中的方法同名,或者是和其他的分类,其他的类中的方法同名,在允许时刻的调用的是哪个方法是不确定的**) This is less likely to be an issue if you’re using categories with your own classes, but can cause problems when using categories to add methods to standard Cocoa or Cocoa Touch classes.(在自己的实现的分类的时候,这可能不是一个问题,但是对系统的框架类,通过分类来添加方法的时候,就有可能导致问题.)
An application that works with a remote web service, for example, might need an easy way to encode a string of characters using Base64 encoding.(例如,一个远程web服务的应用,可能需要一个对字符串进行Base64编码的方法.) It would make sense to define a category on NSString to add an instance method to return a Base64-encoded version of a string, so you might add a convenience method called base64EncodedString.(这时候,似乎对现有的NSString类,添加一个分类方法base64EncodedString来返回编码后的字符串.)
A problem arises if you link to another framework that also happens to define its own category on NSString, including its own method called base64EncodedString. (这个时候,如果你的另外的一个框架中也包含了一个有base64EncodedString的NSString类,问题就来了了.)At runtime, only one of the method implementations will “win” and be added to NSString, but which one is undefined.(在运行时刻,究竟哪个方法会被调用是不确定的,谁竞争成功,谁执行.)
Another problem can arise if you add convenience methods to Cocoa or Cocoa Touch classes that are then added to the original classes in later releases.(另外的一个问题可能是:如果把一个方法添加给了系统的类.) The NSSortDescriptor class, for example, which describes how a collection of objects should be ordered, has always had an initWithKey:ascending: initialization method, but didn’t offer a corresponding class factory method under early OS X and iOS versions.(例如,NSSortDescriptor类,这个类定义了一个对象的集合该怎么去排序,这个类有一个initWithKey:ascending方法,但是这个类在早期的OS X 和iOS版本上并不提供.)
By convention, the class factory method should be called sortDescriptorWithKey:ascending:, so you might have chosen to add a category on NSSortDescriptor to provide this method for convenience.(如果你把这个类方法通过分类,添加到了系统的类中.) This would have worked as you’d expect under older versions of OS X and iOS, but with the release of Mac OS X version 10.6 and iOS 4.0, a sortDescriptorWithKey:ascending: method was added to the original NSSortDescriptor class, meaning you’d now end up with a naming clash when your application was run on these or later platforms.(这样如果在旧版本的系统上,可以工作,**但是在新的版本里,系统添加了sortDescriptorWithKey:ascending:这个方法(以前是你自己通过分类来添加的这个方法.),这样,就造成命名冲突**)
In order to avoid undefined behavior, it’s best practice to add a prefix to method names in categories on framework classes, just like you should add a prefix to the names of your own classes . (为了解决这个未定义的行为,最好的方法是给这个分类名称一个前缀,就像在给类命名的时候一个前缀一样.)You might choose to use the same three letters you use for your class prefixes, but lowercase to follow the usual convention for method names, then an underscore, before the rest of the method name. (你可能会去选择累的前缀,但是,**使用类名前缀+下划线+方法名称**会是一个很好的方法.)For the NSSortDescriptor example, your own category might look like this:(对于NSSortDescriptor这个例子来说,你的分类的名称可能就会像这样:)
```Objective-c
@interface NSSortDescriptor (XYZAdditions)+ (id)xyz_sortDescriptorWithKey:(NSString *)key ascending:(BOOL)ascending;@end
```
This means you can be sure that your method will be used at runtime. (这样就可以保证在运行的时候调用的是我们的方法.)The ambiguity is removed because your code now looks like this:(这样就消除了代码的模凌两可的地方:)

```Objective-c
NSSortDescriptor *descriptor =[NSSortDescriptor xyz_sortDescriptorWithKey:@"name" ascending:YES];
```## Class Extensions Extend the Internal Implementation使用类扩展来扩充内部实现
