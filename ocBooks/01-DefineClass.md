# Defining Classes定义类When you write software for OS X or iOS, most of your time is spent working with objects. Objects in Objective-C are just like objects in other object-oriented programming languages: they package data with related behavior.(当编写OSX或者ios的软件时候,大多数的工作是与对象有关.OC里的对象和其他面向对象编程语言一样,将数据用相关的对象包装起来.)

An app is built as a large ecosystem of interconnected objects that communicate with each other to solve specific problems, such as displaying a visual interface, responding to user input, or storing information.(一个应用相当于一个相互连接的生态系统,用于解决像显示一个用户界面,响应用户输入,或者存储信息等特定的问题.) For OS X or iOS development, you don’t need to create objects from scratch to solve every conceivable problem; instead you have a large library of existing objects available for your use, provided by Cocoa (for OS X) and Cocoa Touch (for iOS).(在实际的开发中,并不需要根据草图来创建解决问题所需要的对象,相反,你可以使用由Cocoa/Cocoa Touch提供的非常多已有的对象.)
Some of these objects are immediately usable, such as basic data types like strings and numbers, or user interface elements like buttons and table views. (一些对象可以立即使用,例如像字符串,数字的基本数据类型和像按钮,表格视图等基本的用户界面元素.)Some are designed for you to customize with your own code to behave in the way you require.(一些对象可以根据需要来自己修改参数以满足需求.) The app development process involves deciding how best to customize and combine the objects provided by the underlying frameworks with your own objects to give your app its unique set of features and functionality.(软件开发的过程涉及到,怎么样通过使用底层框架所提供的对象的自定义,组合来满足应用所需要的特性和功能.)In object-oriented programming terms, an object is an instance of a class. (在OO编程里,对象是类的一个实例.)This chapter demonstrates how to define classes in Objective-C by declaring an interface, which describes the way you intend the class and its instances to be used.(在本章节里,演示在OC里,通过声明interface(interface描述了类的具体内容)来定义类) This interface includes the list of messages that the class can receive, so you also need to provide the class implementation, which contains the code to be executed in response to each message.(interface里包含了类能够接受的信息列表(方法),因此需要在类实现里编写响应消息的代码(也就是方法的具体实现内容)).
## Classes Are Blueprints for Objects 类是对类型的规划(蓝图)
A class describes the behavior and properties common to any particular type of object.(一个类描述对任何特定类型的对象所共同拥有的行为和属性.) For a string object (in Objective-C, this is an instance of the class NSString), the class offers various ways to examine and convert the internal characters that it represents. (对字符串对象(在OC里,字符串对象是NSSting类的一个实例),类提供了非常多的方法来检车和转换内部的字符.)Similarly, the class used to describe a number object (NSNumber) offers functionality around an internal numeric value, such as converting that value to a different numeric type.(类似的,描述数字的对象,NSNumber类提供了内部数字的很多功能,例如转换数据类型.)
In the same way that multiple buildings constructed from the same blueprint are identical in structure, every instance of a class shares the same properties and behavior as all other instances of that class. (同样的,通过结构中规划来的多绑定是同样的,就是说从类生成的每一个类的实例对象都有相同的属性和方法.)Every NSString instance behaves in the same way, regardless of the internal string of characters it holds.(不管每个字符串内部存放的是什么字符组合,NSString的实例都具有相同的行为.)Any particular object is designed to be used in specific ways. (设计的每一个特定的对象,是通过特定的方法来使用的.)You might know that a string object represents some string of characters, but you don’t need to know the exact internal mechanisms used to store those characters. (可能你知道一个字符串对象代表了一些字符,但是并不需要了解如何存储这些的字符的内部实现的机制.)You don’t know anything about the internal behavior used by the object itself to work directly with its characters, but you do need to know how you are expected to interact with the object, perhaps to ask it for specific characters or request a new object in which all the original characters are converted to uppercase.(不需要去了解对象内部的实现机制,但是需要知道如何与对象进行交互,例如让特定的字符组或者是一个字符串对象,把转换为大写字母.)
In Objective-C, the class interface specifies exactly how a given type of object is intended to be used by other objects. In other words, it defines the public interface between instances of the class and the outside world.(在OC里,定义类的时候,详细指定了由类所生成的对象是如何使用的,换句话说,类定义了类实例和外部世界沟通的接口.)
## Mutability Determines Whether a Represented Value Can Be Changed 可变性决定了代表值能否被改变Some classes define objects that are immutable.(一些类定义的对象是不可以被改变的) This means that the internal contents must be set when an object is created, and cannot subsequently be changed by other objects. (这就意味着这个当对象创建的时候就需要指定内容,并且对象随后不能被其他对象所改变.)In Objective-C, all basic NSString and NSNumber objects are immutable. If you need to represent a different number, you must use a new NSNumber instance.(在OC里,所有的NSStrng和NSNumber对象都是不可以改变的,如果你想代表一个不同的数,那么你必须用一个新的NSNumber实例.)
Some immutable classes also offer a mutable version. (一些不可变的类也提供了一个可以改变的版本.)If you specifically need to change the contents of a string at runtime, for example by appending characters as they are received over a network connection, you can use an instance of the NSMutableString class.(如果你在运行的时候需要改变一个字符串的内容,例如通过网络接收到字符添加到字符后,那你可以使用NSMutableString类的实例.) Instances of this class behave just like NSString objects, except that they also offer functionality to change the characters that the object represents.(NSMutableString类的实例和NSSting类的方法相似,但是它还提供了改变对象所代表字符串的功能.)
Although NSString and NSMutableString are different classes, they have many similarities. (尽管NSString,NSMutableString是不同的类,但是它们有很多相同之处.)Rather than writing two completely separate classes from scratch that just happen to have some similar behavior, it makes sense to make use of inheritance.(,由于这两个类有很多相同之处,所以不是根据草图编写两个完全不同的类,这个时候使用继承难道不是很明智么?)
## Classes Inherit from Other Classes 类的继承
In the natural world, taxonomy classifies animals into groups with terms like species, genus, and family. (在真实世界里,在分类学中,动物被分类为像种,类,科.)These groups are hierarchical, such that multiple species may belong to one genus, and multiple genera to one family.(这种组合是分层次的,就是说很多物种可能属于一个属,很多属可能是一个科.)



Gorillas, humans, and orangutans, for example, have a number of obvious similarities.(例如,大猩猩,人类,猿类有很多的相似之处.) Although they each belong to different species, and even different genera, tribes, and subfamilies, they are taxonomically related since they all belong to the same family (called “Hominidae”), as shown in Figure 1-1 (page 13).(尽管,大猩猩,人,猿可能分属于不同种类,或者属,甚至子科,但是它们都可以共同属于一个"人科".)


In the world of object-oriented programming, objects are also categorized into hierarchical groups. (在面向对象编程的领域,对象也被分类为分层次的组.)Rather than using distinct terms for the different hierarchical levels such as genus or species, objects are simply organized into classes.(对象不像分类学里被分类为种,属等,对象仅仅被组织为类.) In the same way that humans inherit certain characteristics as members of the Hominidae family, a class can be set to inherit functionality from a parent class.(就像人类继承了人科的某些特性一样,一个类也可以继承父类的功能属性.)

When one class inherits from another, the child inherits all the behavior and properties defined by the parent. (当一个类继承另外一个类的时候,子类继承到父类所有的行为和属性.)It also has the opportunity either to define its own additional behavior and properties, or override the behavior of the parent.(子类既可以定义自己的额外的行为和属性,也可以重写从父类继承到的行为.)

In the case of Objective-C string classes, the class description for NSMutableString specifies that the class inheritsfromNSString,asshowninFigure1-2(page13).(例如,在OC的string类里,NSMutablesString继承自NSString.)
All of the functionality provided by NSString is available in NSMutableString, such as querying specific characters or requesting new uppercase strings, but NSMutableString adds methods that allow you to append, insert, replace or delete substrings and individual characters.(在NSString里提供的所有的功能,NSMutableString都有,例如查询特定的字符,转换大小写,除此之外,NSMutableString还增加了例如字符串添加,替换,删除子串,删除特定字符等功能.)## The Root Class Provides Base Functionality 基类提供基本的功能方法
In the same way that all living organisms share some basic “life” characteristics, some functionality is common across all objects in Objective-C.(所有活着的有机物都有生命,与此类似,OC里所有的对象都有一些共同的功能.)When an Objective-C object needs to work with an instance of another class, it is expected that the other class offers certain basic characteristics and behavior. (一个OC对象和另外的一个类的实例一起工作的时候,就需要另外的类能够提供一些基本的特性和行为.)For this reason, Objective-C defines a root class from which the vast majority of other classes inherit, called NSObject. (基于这个原因,OC定义了一个根类NSObject,这样绝大多数的其他类都继承自NSObject.)When one object encounters another object, it expects to be able to interact using at least the basic behavior defined by the NSObject class description.(当一个对象遇到另外一个对象的时候,我们期望另外的这个对象,至少有一些在NSObject定义的基本的行为.这样,我们就可以和这个对象进行交互了.)

When you’re defining your own classes, you should at a minimum inherit from NSObject. (当定义我们自己的类的时候,我们至少需要继承自NSObject.)In general, you should find a Cocoa or Cocoa Touch object that offers the closest functionality to what you need and inherit from that.(通常来说,我们需要寻找一个与满足我们需求最接近的的Cocoa/CocoaTouch对象,并且继承它.)If you want to define a custom button for use in an iOS app, for example, and the provided UIButton class doesn’t offer enough customizable attributes to satisfy your needs, it makes more sense to create a new class inheriting from UIButton than from NSObject.(在一个iOS app,如果希望自定义一个按钮,但是已有的UIButton不能满足我们自定义属性的需求,这时,明智的方法创建一个新的类继承自UIButton.) If you simply inherited from NSObject, you’d need to duplicate all the complex visual interactions and communication defined by the UIButton class just to make your button behave in the way expected by the user. (如果仅仅是继承NSObject,你还需要去复制UIButton类所有的可视互动和沟通方法.)Furthermore, by inheriting from UIButton, your subclass automatically gains any future enhancements or bug fixes that might be applied to the internal UIButton behavior.(此外,通过继承UIButton,你的类将会自动的获得UIButton的增强和bug的修复.)The UIButton class itself is defined to inherit from UIControl, which describes basic behavior common to all user interface controls on iOS.(UIButton类继承了UIControl类,UIControl类描述了iOS上通用的用户界面.) The UIControl class in turn inherits from UIView, giving it functionality common to objects that are displayed on screen. (UIControl类又继承自UIView类,UIView类提供了屏幕上显示对象的一些共同的方法.) UIView inherits from UIResponder, allowing it to respond to user input such as taps, gestures or shakes. (UIView继承自UIResponder,UIResponder类提供了响应点击,手势,摇动的方式.)Finally, at the root of the tree, UIResponder inherits from NSObject, as shown in Figure 1-3 (page 14).(最后,UIResponder继承自根类NSObject.)
NSObject<--UIResponder<--UIView<--UIControl<--UIButtonThis chain of inheritance means that any custom subclass of UIButton would inherit not only the functionality declared by UIButton itself, but also the functionality inherited from each superclass in turn. (继承类的链条意味着,如果一个类继承了UIButton,那么它不仅有UIButton的方法,而且还有继承了祖宗类的功能方法.)You’d end up with a class for an object that behaved like a button, could display itself on screen, respond to user input, and communicate with any other basic Cocoa Touch object.(如果类所生成的对象,例如一个button,能够显示在屏幕上,能够响应用户输入,能够和Cocoa/CocoaTouch其他的对象相互沟通.)
It’s important to keep the inheritance chain in mind for any class you need to use, in order to work out exactly what it can do. (为了弄明白类能够做什么,就需要十分重视继承链条,通过链条了解类什么作什么.)The class reference documentation provided for Cocoa and Cocoa Touch, for example, allows easy navigation from any class to each of its superclasses.(Cocoa,CocoaTouch的类文件参考可以导航到它的任意父类.) If you can’t find what you’re looking for in one class interface or reference, it may very well be defined or documented in a superclass further up the chain.(如果找不到一个类的说明和参考,那么它很有很能在父类,间接父类,整个继承链条中的某个类,有着详细的说明.)
# The Interface for a Class Defines Expected Interactions类声明 定义了预期的功能
One of the many benefits of object-oriented programming is the idea mentioned earlier—all you need to know in order to use a class is how to interact with its instances. (面向对象编程的一个个好处就之前我们提到的一个思想:为了使用一个类,必须知道如何和类的实例进行交互.)More specifically, an object should be designed to hide the details of its internal implementation.(更加具体的,设计一个类的时候,应该隐藏内部具体实现过程.)
If you use a standard UIButton in an iOS app, for example, you don’t need to worry about how pixels are manipulated so that the button appears on screen. All you need to know is that you can change certain attributes, such as the button’s title and color, and trust that when you add it to your visual interface, it will be displayed correctly and behave in the way you expect.(在一个iOS应用中,使用一个标准的UIButton的时候,不需要担心一个像素是如何显示在屏幕上的.所需要关注的是,可以改变UIButton的属性,例如,button的标题,颜色,相信,当修改了属性的时候,就应该是按照预期的一样,显示在屏幕上.)
When you’re defining your own class, you need to start by figuring out these public attributes and behaviors.(在设计一个类的时候,需要详细了解public的类属性和行为.) What attributes do you want to be accessible publicly? (什么属性应该被设计为公开的?)Should you allow those attributes to be changed? (这些属性应该被公开么?)How do other objects communicate with instances of your class?(其他的对象改怎么和设计的类所生成的对象进行交互?)
This information goes into the interface for your class—it defines the way you intend other objects to interact with instances of your class. (这就涉及到类的声明的具体细节,在类的声明里,里将详细定义我们的类和其他的类怎么交互.)The public interface is described separately from the internal behavior of your class, which makes up the class implementation.(公共的接口应该和类内部的行为分开来描述) In Objective-C, the interface and implementation are usually placed in separate files so that you only need to make the interface public.(在OC里,声明(接口)和实现通常放在不同的文件里,这样就很容易使接口公开出来.)
# Basic Syntax 基本的语法
The Objective-C syntax used to declare a class interface looks like this:(在OC的语法里,声明一个类的接口如下:)
```
@interface SimpleClass : NSObject@end```
This example declares a class named SimpleClass, which inherits from NSObject.(这个例子声明了一个继承自NSObject的名为SimpleClass的类)
The public properties and behavior are defined inside the @interface declaration.(公开的属性和行为定义在声明内部.) In this example, nothing is specified beyond the superclass, so the only functionality expected to be available on instances of SimpleClass is the functionality inherited from NSObject.(在这个例子里,除指定了父类之外,没有其他的任何东西,所以,这个类实例的全部功能就是继承自父类NSObject类的功能.)

#Properties Control Access to an Object’s Values 属性控制了一了对象值的访问
Objects often have properties intended for public access.(对象通常会有一些提供外部访问的属性.) If you define a class to represent a human being in a record-keeping app, for example, you might decide you need properties for strings representing a person’s first and last names.(例如在一个排行榜app里，设计一个代表人的类，那么需设计人的姓，名两个属性。)Declarations for these properties should be added inside the interface, like this:(在接口中,属性的声明可以像这样来写:)
```@interface Person : NSObject@property NSString *firstName;@property NSString *lastName;@end````
In this example, the Person class declares two public properties, both of which are instances of the NSString class.
(在这个例子里,声明了2个公开的属性,它们都是NSString类的实例)Both these properties are for Objective-C objects, so they use an asterisk to indicate that they are C pointers. (这两个属性都是OC的对象,因此,它们使用了星号来代表它们是C指针.)They are also statements just like any other variable declaration in C, and therefore require a semicolon at the end.(它们和C里面的其他的变量定义一样,也是一个语句,因此,在最后需要一个分号)
You might decide to add a property to represent a person’s year of birth to allow you to sort people in year groups rather than just by name.(你可以会增加一个代表人生日年份的属性,这样就可以对人通过年份来排序,而不是仅仅通过姓名排序.) You could use a property for a number object :(你可能会用一个数字对象作为属性:)

```
@property NSNumber *yearOfBirth;
```but this might be considered overkill just to store a simple numeric value.(但是为了存储一个简单的数字而使用数字对象,有点大材小用了.) One alternative would be to use one of the primitive types provided by C, which hold scalar values, such as an integer:(一个替代的方法是,用c提供的原始数据类型来存储,例如一个整形:)```
@property int yearOfBirth;```
#Property Attributes Indicate Data Accessibility and Storage Considerations属性修饰符显示了数据的可访问性,和存储的考虑
The examples shown so far all declare properties that are intended for complete public access. (至此的例子里,所声明的属性都是完全公开访问的.)This means that other objects can both read and change the values of the properties.(这就意味着其他的对象也可以读和改变属性的值.)
In some cases, you might decide to declare that a property is not intended to be changed.(在某些时候,我们希望一些属性是不让被修改的.) In the real world, a person must fill out a large amount of paperwork to change their documented first or last name. (在真实的世界里,一个人需要填写很多的文件才能修改姓名.)If you were writing an official record-keeping app, you might choose that the public properties for a person’s name be specified as read-only, requiring that any changes be requested through an intermediary object responsible for validating the request and approving or denying it.(在一个官方的排行榜APP里,就可能需要将姓名属性设置位只读的,这样,	任何的改变的话,都需要通过一个中间媒介对象来验证请求,提出修改请求,接受或者拒绝请求.)

Objective-C property declarations can include property attributes , which are used to indicate, among other things, whether a property is intended to be read-only. (OC里,可以使用属性修饰符来表明一个属性是否是readonly的)In an official record-keeping app, the Person class interface might look like this:(在一个官方的排行榜里,一个人的类方法的接口可能就是像酱紫的:)
```
@interface Person : NSObject@property (readonly) NSString *firstName;@property (readonly) NSString *lastName;@end```
Property attributes are specified inside parentheses after the @property keyword, and are described fully in Declare Public Properties for Exposed Data.(属性修饰符的位置是在@property关键字之后的括号之中,可以阅读"为暴露的数据声明公开的属性"章节)
#Method Declarations Indicate the Messages an Object Can Receive方法声明表明了一个对象能够接收的消息
The examples so far have involved a class describing a typical model object, or an object designed primarily to encapsulate data.(迄今为止的例子涉及到了一个典型的类声明,或者一个用来封装数据的类.) In the case of a Person class, it’s possible that there wouldn’t need to be any functionality beyond being able to access the two declared properties.(在人的类中,可能除了访问两个声明的属性之外,不需要其他的功能方法.) The majority of classes, however, do include behavior in addition to any declared properties.(然而,大部分的类,除了声明属性之外,确实是需要有行为方法的.)
Given that Objective-C software is built from a large network of objects, it’s important to note that those objects can interact with each other by sending messages.(假定OC软件就是由一系列的对象所构成的,那么一个非常重要的一点就是,对象可以通过发送消息和其他的对象进行交互.) In Objective-C terms, one object sends a message to another object by calling a method on that object.(在OC的专业术语中,一个对象向另外一个对象发送消息,是通过调用另外的那个对象的方法来实现的.)
Objective-C methods are conceptually similar to standard functions in C and other programming languages, though the syntax is quite different.(OC的方法在概念上和C以及其他编程语言是类似的,但是在语法上却是决然不同的.) A C function declaration looks like this:(一个C函数声明可能就像这样:)
```
void SomeFunction();```
The equivalent Objective-C method declaration looks like this:(同样的方法在OC里声明的话,就是像酱紫的:)

```
￼￼- (void)someMethod;
```In this case, the method has no parameters. (在这种情况下,方法没有参数.)The C void keyword is used inside parentheses at the beginning of the declaration to indicate that the method doesn’t return any value once it’s finished.(在方法的声明的时候,C语言的void关键字是放在括号内部的,说明当方法结束的时候是没有任何返回值的.)
The minus sign (-) at the front of the method name indicates that it is an instance method, which can be called on any instance of the class.(方法名称前面的负号表明了,这个方法是一个实例方法,也就是说,这个方法可以被任何类实例来调用.) This differentiates it from class methods, which can be called on the class itself, as described in Objective-C Classes Are also Objects (page 22).(对象方法和类方法不同,类方法可以被类自己调用,这将会在"OC的类也是对象"里说明.)
As with C function prototypes, a method declaration inside an Objective-C class interface is just like any other C statement and requires a terminating semi-colon.(同C方法原型比较,OC里一个类接口的方法声明就像C语句一样,在结尾处也需要一个分号.)
#Methods Can Take Parameters方法可以带参数
If you need to declare a method to take one or more parameters, the syntax is very different to a typical C function.(声明带有一个或多个参数的方法的语法,与典型的C函数方法是大相径庭的.)
For a C function, the parameters are specified inside parentheses, like this:(在C函数里,带参数的方法可能这样声明)
```
void SomeFunction(SomeType value);```An Objective-C method declaration includes the parameters as part of its name, using colons, like this:(在OC里一个带名称参数的方法需要使用冒号,如下)
```
- (void)someMethodWithValue:(SomeType)value;```
As with the return type, the parameter type is specified in parentheses, just like a standard C type-cast.(对于返回值类型,参数类型和标准的C一样,在括号内部指定.)
If you need to supply multiple parameters, the syntax is again quite different from C. (如果需要指定多个参数,OC里的语法和C又不同了.)Multiple parameters to a C function are specified inside the parentheses, separated by commas; in Objective-C, the declaration for a method taking two parameters looks like this:(在C中多个参数是在函数名后的括号中指定,并且通过逗号来分隔的;在OC里的多参数声明可能看起就是酱紫的:)

```
- (void)someMethodWithFirstValue:(SomeType)value1 secondValue:(AnotherType)value2;
```In this example, value1 and value2 are the names used in the implementation to access the values supplied when the method is called, as if they were variables.(在这个例子中,value1和value2是用于当方法被代用的时候的,需要提供的2个参数,就像2个变量一样.)
Some programming languages allow function definitions with so-called named arguments ; it’s important to note that this is not the case in Objective-C.(一些编程语言里允许方法在定义的时候带有命名的参数,注意,在OC里不是这样的.) The order of the parameters in a method call must match the method declaration, and in fact the secondValue: portion of the method declaration is part of the name of the method:(传入被调用函数的参数的顺序,必须和声明的时候一样.事情上,"secondValue:"是方法名称的一部分:)
```
someMethodWithFirstValue:secondValue:```
This is one of the features that helps make Objective-C such a readable language, because the values passed by a method call are specified inline , next to the relevant portion of the method name, as described in You Can Pass Objects for Method Parameters (page 27).(这是帮助OC成为可读性语言的一个特性,因为,调用函数的时传入的参数是在行内指定的,并且是和函数方法名称一部分紧挨着.可以参考"对象作为参数传入"章节)
> Note: (注意)
> The value1 and value2 value names used above aren’t strictly part of the method declaration, which means it’s not necessary to use exactly the same value names in the declaration as you do in the implementation. (value
1和value2值名称不是方法声明中严格的一部分,这就意味着,在声明里使用的名称不必和在实现里使用的名称相同.)(就是说,声明的时候的形参和实现的时候的形参的名称可以不同.)The only requirement is that the signature matches, which means you must keep the name of the method as well as the parameter and return types exactly the same.(唯一的要求是,标志比配,这就意味着方法名需要完全相同,返回这也需要完全相同.)As an example, this method has the same signature as the one shown above:(作为一个例子,这个方法的符号如下:)
```
 (void)someMethodWithFirstValue:(SomeType)info1 secondValue:(AnotherType)info2;```These methods have different signatures to the one above:(下面的方法和上面的方法有不同的标志)

```
- (void)someMethodWithFirstValue:(SomeType)info1 anotherValue:(AnotherType)info2;- (void)someMethodWithFirstValue:(SomeType)info1secondValue:(YetAnotherType)info2;
```
#Class Names Must Be Unique类名必须唯一
It’s important to note that the name of each class must be unique within an app, even across included libraries or frameworks. (类的命名在一个app内必须唯一,即使是在跨包,跨框架的时候也需要唯一.)If you attempt to create a new class with the same name as an existing class in a project, you’ll receive a compiler error.(如果在一个工程内部创建一个同名的类,那么编译器就会报错哦!)
For this reason, it’s advisable to prefix the names of any classes you define, using three or more letters.(出于上面的原因,所以推荐在给类命令的时候,使用三个或者更多的字符作为前缀.) These letters might relate to the app you’re currently writing, or to the name of a framework of reusable code, or perhaps just your initials.(这些前缀的命名可以是与当前写的app相关联,或者是一个可以重复使用的框架,或许是你姓名的首字母.)
All examples given in the rest of this document use class name prefixes, like this:( 文档的剩余的部分的所有的例子都使用类前缀,像这样:)
````
@interface XYZPerson : NSObject@property (readonly) NSString *firstName;@property (readonly) NSString *lastName;@end```> Historical Note:(追溯历史)
>  If you’re wondering why so many of the classes you encounter have an NSprefix, it’s because of the past history of Cocoa and Cocoa Touch.(为什么类名会有前缀捏?这和Cocoa和CocoaTouch的历史有关.) Cocoa began life as the collected frameworks used to build apps for the NeXTStep operating system. (Cocoa是作为框架来开发NeXTStepOS应用应运而生的.)When Apple purchased NeXT back in 1996, much of NeXTStep was incorporated into OS X, including the existing class names. (在1996年,apple购买了NeXT之后,NeXTSetp也被引进到了OS X,包括已有的类名.)Cocoa Touch was introduced as the iOS equivalent of Cocoa; some classes are available in both Cocoa and Cocoa Touch, though there are also a large number of classes unique to each platform.(CocoaTouch和Cocoa一样被引入了iOS,一些类在Cocoa和CocoaTouch中都有,但是这两个平台之间也有很多不同的类.)Two-letter prefixes like NS and UI (for User Interface elements on iOS) are reserved for use by Apple(像NS和UI这2个前缀被保留下来了 .).
Method and property names, by contrast, need only be unique within the class in which they are defined.(与此同时,方法和属性名称只需要在定义的类的内部不同就可以了.) Although every C function in an app must have a unique name, it’s perfectly acceptable (and often desirable) for multiple Objective-C classes to define methods with the same name.(尽管在一个app中,每一个c方法都需要有一个不同的名字,但是,被广泛接受的是在多个OC类中使用相同的方法名称.) You can’t define a method more than once within the same class declaration, however, though if you wish to override a method inherited from a parent class, you must use the exact name used in the original declaration.(尽管在一个类中不能定义重名的方法,但是在继承的时候,如果需要重写方法,这个时候方法名必须和原有的声明一模一样.)

As with methods, an object’s properties and instance variables (described in Most Properties Are Backed by Instance Variables (page 46)) need to be unique only within the class in which they are defined.(在方法内部,对象的属性和实例变量只需要在类的访问内不同就可以 ) If you make use of global variables, however, these must be named uniquely within an app or project.(如果使用了全局变量,那么在一个app/工程之中必须是唯一的.)
Further naming conventions and suggestions are given in Conventions (page 122).(更多的命名约定和建议在"约定"章节中)
# The Implementation of a Class Provides Its Internal Behavior类的实现描述了内部的行为Once you’ve defined the interface for a class, including the properties and methods intended for public access, you need to write the code to implement the class behavior.(一旦把类的接口定义好了(包括提供外部访问的属性和方法),就需要编写类的实现.)
As stated earlier, the interface for a class is usually placed inside a dedicated file, often referred to as a header file, which generally has the filename extension .h. (通常类的接口文件,是单独放在一个.h文件中的.)You write the implementation for an Objective-C class inside a source code file with the extension .m.(可以在.m的源码文件中白哪些OC的类的具体实现.)
Whenever the interface is defined in a header file, you’ll need to tell the compiler to read it before trying to compile the implementation in the source code file.(不管类接口是何时定义在头文件中的,在类的实现的时候,都需要将接口头文件包含进来,这样编译器就能正常的编译一个类了.) Objective-C provides a preprocessor directive, #import, for this purpose. (编译器提供#import的预编译的方法来导入头文件.)It’s similar to the C #include directive, but makes sure that a file is only included once during compilation.(但是在使用的#inclue的时候,确保在编译的时候只包含了一次头文件)Note that preprocessor directives are different from traditional C statements and do not use a terminating semi-colon.(需要注意的是,预编译和传统的C语句是不同的,它不需要结尾添加分号)
## Basic Syntax(基本语法)The basic syntax to provide the implementation for a class looks like this:￼(类的实现的基本语法是这酱紫的:)
```
#import "XYZPerson.h"@implementation XYZPerson@end```
If you declare any methods in the class interface, you’ll need to implement them inside this file.(如果在类接口里声明了任何的方法,都需要在实现文件里去实现)

## Implementing Methods(类的实现)
For a simple class interface with one method, like this:(一个简单的类的接口的声明像这酱紫:)```@interface XYZPerson : NSObject- (void)sayHello;@end
```
the implementation might look like this:
(这个类的实现就是像这酱紫的:)```#import "XYZPerson.h"@implementation XYZPerson- (void)sayHello {    NSLog(@"Hello, World!");}@end
```
This example uses the NSLog() function to log a message to the console. It’s similar to the standard C library printf() function, and takes a variable number of parameters, the first of which must be an Objective-C string.(这个例子中,NSLog的方法在控制行中打印一行信息.有点类似标准C的printf()函数.NSLog方法这里带了一个参数,这里的这个参数必须是一个OC的字符串对象.)
Method implementations are similar to C function definitions in that they use braces to contain the relevant code. (方法的实现和C一样,相关的实现代码都放在大括号中.)Furthermore, the name of the method must be identical to its prototype, and the parameter and return types must match exactly.(除此,方法的名称在类文件中是唯一的,方法的参数和返回值必须比配.(声明的形参的名称和实现的形参的名称可以不一样.))
Objective-C inherits case sensitivity from C, so this method:(OC继承了C里面对字符大小写敏感的特性)
```
- (void)sayhello {}```would be treated by the compiler as completely different to the sayHello method shown earlier.(因此上面的方法和sayHello是两个不同的方法.)
In general, method names should begin with a lowercase letter.(一般的,方法名称应该以小写字母开头) The Objective-C convention is to use more descriptive names for methods than you might see used for typical C functions. (按照OC的约定,方面的命名的比传统的C的方法更具有描述性)If a method name involves multiple words, use camel case (capitalizing the first letter of each new word) to make them easy to read.(如果一个方法需要使用多个单词,使用驼峰命名规则让方法名更加易读.)
Note also that whitespace is flexible in Objective-C. (注意到在OC里的空白更加灵活.)It’s customary to indent each line inside any block of code using either tabs or spaces, and you’ll often see the opening left brace on a separate line, like this:(可以使用tab见和空格键来区分代码块,所以你经常可以看到下面的形式:)
```
- (void)sayHello{    NSLog(@"Hello, World!");}```
Xcode, Apple’s integrated development environment (IDE) for creating OS X and iOS software, will automatically indent your code based on a set of customizable user preferences.(Xcode会根据你的用户配置来自动对齐你代码.) See Changing the Indent and Tab Width in Xcode Workspace Guide for more information(参考"Xcode工作区指南"来改变自动对齐和tab键的宽度.).
You’ll see many more examples of method implementations in the next chapter, Working with Objects (page 24).(你可以在"操作对象"章节里看到更多类的实现的例子.)
# Objective-C Classes Are also Objects OC的类也是对象
In Objective-C, a class is itself an object with an opaque type called Class.(在OC里,类本也是一个对象,这个对象有个不可见的类型叫做类) Classes can’t have properties defined using the declaration syntax shown earlier for instances, but they can receive messages.(类里不能定义属性,但是可以接收消息.)
The typical use for a class method is as a factory method, which is an alternative to the object allocation and initialization procedure described in Objects Are Created Dynamically (page 34). (类方法的典型应用是一个工厂方法,工厂方法是"动态生成对象 "中,分配存储空间和初始化过程的一个可替代的方法.)The NSString class, for example, has a variety of factory methods available to create either an empty string object, or a string object initialized with specific characters, including:(例如,NSString就有很多可用的工厂方法创建,空字符串,指定字符的字符串,如下:)
```  + (id)string;  + (id)stringWithString:(NSString *)aString;  + (id)stringWithFormat:(NSString *)format, ...;  + (id)stringWithContentsOfFile:(NSString *)path encoding:(NSStringEncoding)enc  error:(NSError **)error;  + (id)stringWithCString:(const char *)cString encoding:(NSStringEncoding)enc;
```
As shown in these examples, class methods are denoted by the use of a + sign, which differentiates them from instance methods using a - sign.(在上面的例子里,类方法用一个+号表示,和实例方法使用-号不同.)Class method prototypes may be included in a class interface, just like instance method prototypes. (类方法原型可能包含一个类接口,就像实例方法原型一样.)Class methods are implemented in the same way as instance methods, inside the @implementation block for the class.(类方法的实现和实例方法一样,实现写在类实现代码库中.)